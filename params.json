{"name":"Yii2-angular","tagline":"\"But wait,\" you say, \"Yii is too magical!\"","body":"# Yii2-angular\r\n####\"But wait,\" you say, \"Yii is too magical!\"\r\n\r\nYou're right. Sort of. The magic is in everything Yii does under the covers. And while all of the forms and pages that Gii generates are handy, sometimes they won't _quite_ fit your needs. Especially when you're mixing and mashing up different models in different ways.\r\n\r\nBut still, the rigid MVC architecture is nice to have and makes reading from and writing to the database ~~DROP TABLE~~ drop-dead easy. This part of it is worth hanging on to.\r\n\r\nSo how do we roll our own interface *and* integrate Yii's fancy MVC architecture?\r\n\r\nI've been using a two-pronged approach and it's proven to be quite flexible:\r\n\r\n##Yii's REST service with Angular.js\r\n####\"Hang on there, M&aelig;stro. Isn't Angular overcomplicating things?\"\r\n\r\nNot any more than using Bootstrap or jQuery overcomplicates things. I'll illustrate how they work together as we move along.\r\n\r\n>[Two great tastes that taste great together!](http://youtu.be/DJLDF6qZUX0#t=5)\r\n\r\nWhile we won't need get into which of the two is Chocolate and which is Peanut Butter, here's a quick defense of the Yii/Angular approach:\r\n\r\nWith Yii handling all of your users' requests, every change in data is accompanied with a full page reload. Even with browser caching, that can really slow down the user experience and trigger a ton of redundant server requests. If can we hand off some of the data manipulation to an AJAX-like interface that updates the UI without a full page refresh, we'll end up with a snappier interface and lower network overhead.\r\n\r\nYii is tightly integrated to your database and its models are perfect for providing a RESTful API that returns JSON objects. If you're just learning about [REST](https://en.wikipedia.org/wiki/Representational_state_transfer), Wikipedia is a good place to start.\r\n\r\nTo put it briefly, REST allows us to send out small requests and receive a response with each one. When implemented, you can use the actions `GET`, `PUT`, `POST`, and `DELETE` to act upon the data store.\r\n\r\nHow does this help us as we build web apps? Because Angular has these actions built in using its `$http` service, and sends them as [XHR](https://en.wikipedia.org/wiki/XMLHttpRequest). As soon as it receives a response, it updates every single place it's been referenced in the interface with no extra jQuery tricks and tomfoolery, and better still, with just a few KB changing hands.\r\n\r\n####Why do you keep bashing jQuery?\r\n\r\nI've got nothing but love for jQuery, but like any tool, it's not always the best solution for the challenge we're presented with. Yes, it *can* perform XHR, but it does so with a much lower-level approach than Angular and leaves a lot of the mess of wiring everything together to the poor developer.\r\n\r\n####I'm still skeptical, but show me something in action already!\r\n\r\nI was about to. Increase your calm.\r\n```\r\n<html>\r\n  <body ng-app=\"cupcakes\" ng-controller=\"CupcakeController\">\r\n    . . .\r\n  </body>\r\n</html\r\n```\r\n####`ng-app` ain't no attribute I ever heard of. What kind of witch doctor are you?\r\n\r\nHere's where Angular gets invoked. Any attribute in an html page that starts with `ng-` is called a directive. As the browser renders the page, Angular takes any `ng-` attribute and evaluates it as necessary. This keeps your html looking like html while allowing for dynamic data manipulation at the same time.\r\n\r\nDirectives can take a couple of other forms too:\r\n```\r\n<html>\r\n  <body ng-app=\"cupcakes\" ng-controller=\"CupcakeController\">\r\n    <div id=\"element-directives\">\r\n      <cupcake-name></cupcake-name>\r\n      <cupcake-description></cupcake-description>\r\n      <cupcake-cake-color></cupcake-cake-color>\r\n    </div>\r\n    <div id=\"class-directives\">\r\n      <div class=\"cupcake-name\"></div>\r\n      <div class=\"cupcake-description\"></div>\r\n      <div class=\"cupcake-cake-color\"></div>\r\n    </div>\r\n  </body>\r\n</html>\r\n```\r\n**Element** directives allow you to create your own tags outside the HTML spec. Wacky!\r\n\r\n**Class** directives allow you to bind data to a container based off its class name. Handy if you need css styles to match the container's contents 100% of the time!\r\n\r\nWith the appropriate directive setup in your `CupcakeController`, both of its child `div`s above should render the same content.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}